import {
  createPatternMatchers,
  argumentMatcher,
  leadingMatcher,
  conditionMatcher,
  trailingMatcher,
  cascadingMatcher,
} from '../util/nodeMatchers';
import { NodeMatcherAlternative, ScopeType } from '../typings/Types';

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-scala/master/src/node-types.json | jq '[.[] | select(.type == "_definition" or .type == "_expression" or .type == "_pattern") | .subtypes[].type]'
const STATEMENT_TYPES = [
  // FIXME: What is a "statement" in a language where most traditional statements are expressions
  'alternative_pattern',
  'assignment_expression',
  'block',
  'call_expression',
  'capture_pattern',
  'case_block',
  'case_class_pattern',
  'class_definition',
  'field_expression',
  'function_declaration',
  'function_definition',
  'generic_function',
  'identifier',
  'if_expression',
  'import_declaration',
  'infix_expression',
  'infix_pattern',
  'instance_expression',
  'match_expression',
  'number',
  'object_definition',
  'package_clause',
  'package_object',
  'parenthesized_expression',
  'prefix_expression',
  'string_transform_expression',
  'string',
  'trait_definition',
  'try_expression',
  'tuple_expression',
  'tuple_pattern',
  'type_definition',
  'typed_pattern',
  'val_declaration',
  'val_definition',
  'var_declaration',
  'var_definition',
  'wildcard',
];

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
  statement: STATEMENT_TYPES,
  // treating classes = classlike
  class: ['class_definition', 'object_definition', 'trait_definition'],
  className: ['class_definition[name]', 'object_definition[name]', 'trait_definition[name]'],

  ifStatement: 'if_expression',

  string: ['interpolated_string_expression', 'string'],
  comment: 'comment',
  // lists basic definition is just a function call to a constructor, eg List(1,2,3,4)
  // MISSING: fancy list style: val foo = 1 :: (2 :: (3 :: Nil)) // List(1,2,3)
  list: 'call_expression',
  map: 'call_expression',

  // list.size(), does not count foo.size (field_expression), or foo size (postfix_expression)
  functionCall: 'call_expression',
  namedFunction: 'function_definition',
  // Do we want to consider partial functions as lambdas? eg
  //   foo.map(_ + 1)
  //   foo.map {_ + 1}
  //   foo.map {case x => x + 1}
  // are not under `lambda_expression`
  anonymousFunction: 'lambda_expression',

  argumentOrParameter: argumentMatcher('arguments', 'parameters', 'class_parameters', 'bindings'),

  name: ['*[name]', '*[pattern]'],
  functionName: 'function_definition[name]',

  // Ripped off from Java below
  type: trailingMatcher([
    'generic_type.type_arguments.type_identifier',
    'generic_type.type_identifier',
    'type_identifier',
    'local_variable_declaration[type]',
    'array_creation_expression[type]',
    'formal_parameter[type]',
    'method_declaration[type]',
  ]),

  value: leadingMatcher(['*[declarator][value]', '*[value]'], ['=']),
  condition: conditionMatcher('*[condition]'),
  collectionItem: argumentMatcher('array_initializer'),

  // Pulled from the complete list that isn't implemented above
  // attribute: "???",
  // collectionKey: "???",
  // regularExpression: "???",
  // xmlBothTags: "???",
  // xmlElement: "???",
  // xmlEndTag: "???",
  // xmlStartTag: "???",
};

export default createPatternMatchers(nodeMatchers);
