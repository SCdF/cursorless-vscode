import {
  createPatternMatchers,
  argumentMatcher,
  leadingMatcher,
  conditionMatcher,
  trailingMatcher,
} from '../util/nodeMatchers';
import { NodeMatcherAlternative, ScopeType } from '../typings/Types';

// Generated by the following command:
// > curl https://raw.githubusercontent.com/tree-sitter/tree-sitter-scala/master/src/node-types.json | jq '[.[] | select(.type == "_definition" or .type == "_expression" or .type == "_pattern") | .subtypes[].type]'
const STATEMENT_TYPES = [
  // FIXME: is this right? What is a "statement" in a language where most traditional statements are expressions
  'alternative_pattern',
  'assignment_expression',
  'block',
  'call_expression',
  'capture_pattern',
  'case_block',
  'case_class_pattern',
  'class_definition',
  'field_expression',
  'function_declaration',
  'function_definition',
  'generic_function',
  'identifier',
  'if_expression',
  'import_declaration',
  'infix_expression',
  'infix_pattern',
  'instance_expression',
  'match_expression',
  'number',
  'object_definition',
  'package_clause',
  'package_object',
  'parenthesized_expression',
  'prefix_expression',
  'string_transform_expression',
  'string',
  'trait_definition',
  'try_expression',
  'tuple_expression',
  'tuple_pattern',
  'type_definition',
  'typed_pattern',
  'val_declaration',
  'val_definition',
  'var_declaration',
  'var_definition',
  'wildcard',
];

const nodeMatchers: Partial<Record<ScopeType, NodeMatcherAlternative>> = {
  statement: STATEMENT_TYPES,
  // XXX: v BELOW HERE WORKS
  // TODO: objects defined as classes?
  class: 'class_definition',
  // XXX ^ ABOVE HERE WORKS
  className: 'class_definition[name]',
  ifStatement: 'if_expression',
  string: 'string_literal',
  comment: 'comment',
  anonymousFunction: 'lambda_expression',
  list: 'array_initializer',
  functionCall: 'method_invocation',
  map: 'block',
  name: ['*[declarator][name]', '*[name]', 'formal_parameter.identifier!'],
  namedFunction: ['method_declaration', 'constructor_declaration'],
  type: trailingMatcher([
    'generic_type.type_arguments.type_identifier',
    'generic_type.type_identifier',
    'type_identifier',
    'local_variable_declaration[type]',
    'array_creation_expression[type]',
    'formal_parameter[type]',
    'method_declaration[type]',
  ]),
  functionName: [
    'method_declaration.identifier!',
    'constructor_declaration.identifier!',
  ],
  value: leadingMatcher(['*[declarator][value]', '*[value]'], ['=']),
  condition: conditionMatcher('*[condition]'),
  collectionItem: argumentMatcher('array_initializer'),
  argumentOrParameter: argumentMatcher('formal_parameters', 'argument_list'),
};

export default createPatternMatchers(nodeMatchers);
